{"tagline":"Infrastructure orchestration engine","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"We need more than \"ssh-in-a-for-loop\". Our infrastructure get more complex every day and we need a tool that can choreograph an intricate dance of services, servers and commands in a manageable way.\r\n\r\nMastermind is an _infrastructure orchestration engine_. Its purpose is to provide the ability to compose and automate complex tasks with predefined and reproducible outcomes.\r\n\r\nMastermind uses a special domain-specific language for its process definitions, but if you're familiar with [Ruby](http://www.ruby-lang.org/), it should feel right at home.\r\n\r\n# Using Mastermind\r\n\r\nHere's an example of a basic sysadmin workflow, as implemented by Mastermind. Here, we create and destroy an EC2 instance, while notifying a Campfire room of each action performed.\r\n\r\n```ruby\r\ndefinition = Definition.new({\r\n  name: \"create_and_destroy_ec2_server\",\r\n    content: %q{\r\n    create_ec2_server image_id: '${image_id}',\r\n      flavor_id: '${flavor_id}',\r\n      key_name: '${key_name}',\r\n      region: '${region}',\r\n      availability_zone: '${availability_zone}',\r\n      groups: '$f:groups', \r\n      tags: '$f:tags'\r\n\r\n    # ${instance_id} is a field added by the `create_ec2_server` action\r\n    notify_campfire message: \"${instance_id} created!\"\r\n\r\n    destroy_ec2_server instance_id: '${instance_id}', region: '${region}'\r\n\r\n    notify_campfire message: \"${instance_id} destroyed!\"\r\n  }\r\n})\r\n\r\njob = Job.new({\r\n  name: \"new ec2 instance workflow\",\r\n  definition: \"create_and_destroy_ec2_server\",\r\n  fields: {\r\n    flavor_id: \"t1.micro\",\r\n    image_id: \"ami-fe5bd4ce\",\r\n    region: \"us-west-2\",\r\n    availability_zone: \"us-west-2a\",\r\n    key_name: \"storm\",\r\n    groups: [ \"default\" ],\r\n    tags: { 'Name' => \"foo.example.com\" }\r\n  }\r\n})\r\n\r\njob.launch\r\n```\r\n\r\nMastermind has four basic pieces: a job; a definition; a participant; and a target.\r\n\r\n## Job\r\n\r\nA job is a template, tied to a definition. Jobs launch workflows.\r\n\r\n### Attributes\r\n\r\n* name (String) - The name of the job.\r\n* definition (String) - The name of the definition that this job will launch.\r\n* fields (Hash) - The initial attributes used by the definition, and ultimately each participant.\r\n\r\n### Example job\r\n\r\n```ruby\r\njob = Job.new({\r\n  name: \"do the needful\",\r\n  definition: \"execute remote ssh\",\r\n  fields: {\r\n    host: \"db-master.example.com\",\r\n    user: \"root\",\r\n    key_data: \"-----BEGIN RSA PRIVATE KEY-----\\n-----END RSA PRIVATE KEY-----\"\r\n    command: \"rm -rf /\"\r\n  }\r\n})\r\n```\r\n\r\n## Definition\r\n\r\nA definition is the workflow itself. It's the document that describes exactly what tasks will be performed, and in what order.\r\n\r\n### Attributes\r\n\r\n* name (String) - The name of the definition.\r\n* content (Array) - The process definition.\r\n\r\n### Dollar notation ${...}\r\n\r\nMastermind scans strings in process definition for `${...}` placeholders and substitutes them for fields provided by the job or fields added by participants during the execution of the process. Any field interpolated by `${...}` will be the string representation of the value. If the literal value of the field is needed (for instance, if a field holds an array of values), use the `$f:` notation instead.\r\n\r\nGiven the job fields:\r\n\r\n```ruby\r\n{\r\n  :name => \"Dan Ryan\",\r\n  :titles => [ \"Future Mayor of Lansing, MI\", \"Thoulght Leader\" ]\r\n}\r\n```\r\n\r\nThe following definition...:\r\n\r\n```ruby\r\nperson :name => \"${name}\", :titles => \"$f:titles\"\r\n```\r\n\r\n...gets compiled to:\r\n\r\n```ruby\r\nperson :name => \"Dan Ryan\", :titles => [ \"Future Mayor of Lansing, MI\", \"Thoulght Leader\" ]\r\n```\r\n\r\n## Example definition\r\n\r\n```ruby\r\nDefinition.new(\r\n  :name => \"standard syntax\",\r\n  :content => %q{\r\n    run_ssh host:     '${host}',\r\n            user:     '${user}',\r\n            key_data: '${key_data}',\r\n            command:  '${command}'\r\n  }\r\n).to_pdef\r\n\r\n# => compiled definition\r\n#\r\n# [\"define\",\r\n#  {\"name\"=>\"watee\"},\r\n#  [[\"run_ssh\",\r\n#    {\"host\"=>\"${host}\",\r\n#     \"user\"=>\"${user}\",\r\n#     \"key_data\"=>\"${key_data}\",\r\n#     \"command\"=>\"${command}\"},\r\n#    []]]]\r\n```\r\n\r\nThe previous example uses Ruby 1.9-style hash syntax. If you prefer the look of the \"hash rocket\", you are more than welcome to use it instead!\r\n\r\n```ruby\r\nDefinition.new(\r\n  :name => \"hash rockets\",\r\n  :content => %q{\r\n    run_ssh :host     => '${host}', \r\n            :user     => '${user}', \r\n            :key_data => '${key_data}', \r\n            :command  => '${command}'\r\n  }\r\n).to_pdef\r\n\r\n# => compiled definition\r\n#\r\n# [\"define\",\r\n#  {\"name\"=>\"watee\"},\r\n#  [[\"run_ssh\",\r\n#    {\"host\"=>\"${host}\",\r\n#     \"user\"=>\"${user}\",\r\n#     \"key_data\"=>\"${key_data}\",\r\n#     \"command\"=>\"${command}\"},\r\n#    []]]]\r\n```\r\n\r\nYou can even mix in plain old Ruby if you're feeling adventurous!\r\n```ruby\r\nhosts = %w( host1.example.com host2.example.com host3.example.com )\r\n\r\nDefinition.new(\r\n  :name => \"plain ol' ruby!\",\r\n  :content => %q{\r\n    hosts = %w( host1.example.com host2.example.com host3.example.com )\r\n    hosts.each do |host|\r\n      run_ssh :host     => host, \r\n              :user     => '${user}', \r\n              :key_data => '${key_data}', \r\n              :command  => '${command}'\r\n    end\r\n  }\r\n).to_pdef\r\n\r\n# => compiled definition\r\n#\r\n# [\"define\",\r\n#  {\"name\"=>\"watee\"},\r\n#  [[\"run_ssh\",\r\n#    {\"host\"=>\"host1.example.com\",\r\n#     \"user\"=>\"${user}\",\r\n#     \"key_data\"=>\"${key_data}\",\r\n#     \"command\"=>\"${command}\"},\r\n#    []],\r\n#   [\"run_ssh\",\r\n#    {\"host\"=>\"host2.example.com\",\r\n#     \"user\"=>\"${user}\",\r\n#     \"key_data\"=>\"${key_data}\",\r\n#     \"command\"=>\"${command}\"},\r\n#    []],\r\n#   [\"run_ssh\",\r\n#    {\"host\"=>\"host3.example.com\",\r\n#     \"user\"=>\"${user}\",\r\n#     \"key_data\"=>\"${key_data}\",\r\n#     \"command\"=>\"${command}\"},\r\n#    []]]]\r\n```\r\n\r\n## Participant\r\n\r\nA participant is responsible for performing tasks as specified by the definition. There are many types of participants. A participant can provision a server, send notifications, or even execute remote commands.\r\n\r\n### Attributes\r\n\r\nParticipant attributes vary depending on their purpose.\r\n\r\n### Example participant\r\n\r\n```ruby\r\nrequire 'net/ssh'\r\n\r\nmodule Participant::Remote\r\n  class SSH < Participant\r\n    register :ssh\r\n    \r\n    action :run do\r\n      requires :host, :user, :key_data, :command\r\n      \r\n      target.output = run_ssh(target.command)\r\n      return {}\r\n    end\r\n\r\n    def run_ssh(command)\r\n      session = Net::SSH.start(target.host, target.user, { key_data: target.key_data })\r\n      output = nil\r\n\r\n      session.open_channel do |ch|\r\n        ch.request_pty\r\n        ch.exec command do |ch, success|\r\n          raise ArgumentError, \"Cannot execute #{target.command}\" unless success\r\n          ch.on_data do |ichannel, data|\r\n            output = data\r\n          end\r\n        end\r\n      end\r\n\r\n      session.loop\r\n      session.close\r\n      return output if output\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n## Target\r\n\r\nA target is the resource that the participant modifies. The target can have a variety of attributes, depending on the participant's needs. The target performs the majority of validations to ensure the participant has the right fields to execute its actions.\r\n\r\n### Attributes\r\n\r\nTarget attributes vary depending on their purpose.\r\n\r\n### Example target\r\n\r\n```ruby\r\n# Modules are used as namespaces.\r\nmodule Target::Remote\r\n\r\n  # All targets inherit from Target\r\n  class SSH < Target\r\n  \r\n    # We'll refer to this target elsewhere by the name we use to register it.\r\n    register :ssh\r\n\r\n    # Various attributes of the target. The :type option typecasts the attribute.\r\n    attribute :command, type: String\r\n    attribute :host, type: String\r\n    attribute :user, type: String\r\n    attribute :key_data, type: String  \r\n    attribute :output, type: String\r\n    \r\n    # Validate the target to ensure we have the right details.\r\n    validates! :command, :host, :user, :key_data,\r\n      presence: true\r\n  end\r\nend\r\n```\r\n\r\n# Dependencies\r\n\r\n* Ruby >= 1.9.2\r\n* [Ruote](http://ruote.rubyforge.org)\r\n* [PostgreSQL](http://www.postgresql.org)\r\n* [Redis](http://redis.io)\r\n\r\nMastermind uses PostgreSQL to store jobs and process definitions, Redis as a queue for workflow processes, and Ruote as the underlying \"operating system\" for workflow execution.\r\n\r\n# API\r\n\r\n```ruby\r\nraise NotImplementedError, \"Documentation coming soon!\"\r\n```\r\n\r\n# Custom participants/targets \r\n\r\n```ruby\r\nraise NotImplementedError, \"Documentation coming soon!\"\r\n```","name":"Mastermind"}